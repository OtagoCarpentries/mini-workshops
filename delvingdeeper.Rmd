---
title: "Delving Deeper into R"
description: |
  A deeper look into topics that get skipped.
author:
  - name: Murray Cadzow 
    url: https://github.com/murraycadzow
    affiliation: University of Otago
    affiliation_url:
  - name: Matt Bixley
    affiliation: NeSI 
date: "`r Sys.Date()`"
output: 
  distill::distill_article:
    toc: yes
    css: style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




Time: 90 minutes

- 30 data structures
- 30 functions
- 30 loops

Description: This workshop will extend your understanding of R and cover how to interact with non-data.frame structured data such as vectors, matrices and lists. We'll also look at creating your own functions and loops.

Learning objectives:

- data structures
    - homogenous structures
        - vectors
        - matrix
    - heterogenous structures
        - lists
        - data.frame/tibble
- create functions
- create loops
- creating/running scripts


## Data structures

Heavy reliance on content in http://adv-r.had.co.nz/Data-structures.html


### Structures



Homogenous: vector, matrix

```{r}
example_vector <- c(1,2,5,6)
example_vector

example_matrix <- matrix(c(1:10), nrow = 2, byrow = TRUE)
example_matrix
```


Heterogenous: list, data.frame (tibble), data.table(?)


```{r}
example_list <- list(1:3, "a", c(TRUE, FALSE, TRUE), c(2.3, 5.9))
example_list
```



- `str`
- `class`
- `attributes`
- `typeof`
- `length`
- `dim`

```{r, eval = FALSE}
items <- c("fork" = 5, "table" = 1,"knife" = 6,"spoon" = 4)
names(items)

attributes(items)


attributes(mtcars)

```



### Atomics

- numeric
- logical
- character

Coercion

All elements of an atomic vector must be the same type, so when you attempt to combine different types they will be coerced to the most flexible type. Types from least to most flexible are: 
logical -> integer -> double -> character.



### Subsetting

http://adv-r.had.co.nz/Subsetting.html

Subsetting operators:

`[` versus `[[` versus `$`

`[`


There are two main methods of subsetting in R, the first is by specifying the numbered positions (index) from the data structure we have. The second is by providing a logical vector - usually created through a conditional statement.

#### Conditional

These statements rely on a test (condition/comparison) that results in a boolean (`TRUE`/`FALSE`) to determine what gets subsetted (or in the context of functions, run). Boolean logic operators can be used in to modify or combine tests to result in a single `TRUE` or `FALSE`.


Boolean Operation | Symbol in R
---|---
NOT | !
OR | \|
AND | &

These can be combined with the comparison operators (`==`, `!=`, `<`, `<=`, `>`, `>=`) to combine statements together into more complex logic statements. The result of the NOT, AND, and OR can be seen in the below logic table:

Statement | Becomes
---|---|---|---
  !TRUE | `r !TRUE`
 !FALSE | `r !FALSE` 
TRUE & TRUE | `r TRUE & TRUE`
TRUE & FALSE | `r TRUE & FALSE`
FALSE & TRUE | `r FALSE & TRUE`
FALSE & FALSE | `r FALSE & FALSE`
TRUE \| TRUE | `r TRUE | TRUE`
TRUE \| FALSE | `r TRUE | FALSE`
FALSE \| TRUE | `r FALSE | TRUE`
FALSE \| FALSE | `r FALSE | FALSE`

For subsetting the final logical vector tells R which items to pull out - the positions that are TRUE. This logical vector needs to either be the same length as the vector being subsetted, or a factor of the length (so the vector can be 'recycled').

```{r}
my_vec <- c("cat","dog","mouse", "horse")

# pull out the first and last elements
my_vec[c(TRUE, FALSE, FALSE, TRUE)]

# pull out the "odd" elements
my_vec[c(TRUE, FALSE)]
```

#### Positional








```{r}
example_list

example_list[[c(1,2)]]

example_list[c(1,2)]
```
## Exercises




## Functions

A function in R is comprised of four parts:

1. a name
2. inputs (arguments/variables)
3. the body (the code that does something)
4. output (what gets returned after the body has run)

As you have been using R you will have noticed that many tasks have a particular function already available for you to use, such as `mean` or `sd`. In this section we are going to learn how to make our own functions. We can define our own functions using the `function()` function. Inside the parenthesis we define what variables are going to be passed to our function and curly braces contain the body of the function. If we want to return a value from our function R will automatically return the result of the last line of the function body or we end can do so explicitly with `return()`. We can assign this new function to a variable so that we call on it later, it is possible to have an anonymous function but these are usually found as part of map or the apply family but we wonâ€™t be covering anonymous functions in this workshop. To call our new function we now use the variable name and pass any required arguments.

Here is an example of how to create a function:

```{r, eval = FALSE}
name <- function(variables) {
  
}
```

**NB:** in RStudio you can get a code snippet/template by typing "fun" and hitting `<tab>`

Here is an example function that will double the value of the provided number:

```{r, eval = TRUE, echo = TRUE}
# Doubles the provided number
double <- function( num ){
  num * 2
}

double(2)
```

**Important: Functions don't auto-update when you modify the code that creates them, you must re-run the entire function code block.**

We can also have multiple arguments for our functions:

```{r, eval = TRUE, echo = TRUE}
# Calculates BMI on a supplied height (m) and weight (kg)
calcBMI <- function(height, weight){
  weight / height ^ 2
}


calcBMI(height = 1.68, weight = 73)
```

**NB:** Variables declared only inside a function don't exist outside of the function -- see the _Scope_ section.


## Iteration

What is the point of learning about iteration? Similar to the reasons to create functions, iteration provides us a tool to be able to do repetitive tasks without having to copy and paste a lot of code. Take for instance the following example code that would read in csv files for a given country and then calculate the mean GDP for each:

```{r, eval = FALSE}

data_nzl <- read_csv("gapminder_countries/nzl.csv")
data_aus <- read_csv("gapminder_countries/aus.csv")
data_usa <- read_csv("gapminder_countries/usa.csv")

# calculate the mean gdp from each country
mean(data_nzl$gdp)
mean(data_aus$gdp)
mean(data_usa$gsp)
```

Notice that there is a lot of code duplication (`read_csv`, and `mean` are duplicated for each country).  In this example there is also the inclusion of a typo which is a very common mistake to make when changing inputs after copy and pasting - did you spot it? What happens if we need include another 20 or 100 countries? What happens if we also needed to calculate the median GDP for each? It quickly becomes quite laborious to scale. This is where iteration is useful, as it is all about providing a mechanism to specify how to repeat things.

In an abstract form, the above example could be captured like this:

```
1. make a list of all the csv files
2. for each csv file in the list:
    - calculate the mean of the gdp column
```

This abstraction of the problem now gives us the steps to follow and deals with the heart of the problem rather than having to worry about a specific implementation.


### The `for` Loop

#### Palmer Penguins Dataset
We are going to use the [Palmer Penguins](https://allisonhorst.github.io/palmerpenguins/) dataset with our `for` loops. A set of Phenotypes from 3 Species and 3 Islands put together by Alison Horst

```{r penguins}
if (!require("palmerpenguins")) install.packages("palmerpenguins")
library(palmerpenguins)
```


`for` loops usually contain the following parts:

1. an **output** - somewhere to store the results from the loop
2. an **input** set of items to do something to (a vector)
3. loop **body** - code that will do something for a single value of the set.


The most common loop is the **for** loop. The template is as follows:

```{r, eval = FALSE}
for (variable in vector) {
  # loop body i.e. what to do each time
}
```

**NB:** You can get the `for` loop code snippet in RStudio by typing `for` then hitting `<tab>` and selecting "for {snippet}" from the drop down.

When you see a `for` loop you can read it like a sentence: for each thing in my collection of things; I will do something to first thing; and then choose the next thing, do something, and repeat, until I have done something to each of my things in my collection. 

We'll compare this snippet to the following example which will print out the numbers 1 to 3 to explain what is going on.
 

```{r, eval = TRUE, echo = TRUE}
for( num in 1:3 ){
  print( num )
}
```

In this example, we wanted to `print` out each item from our set. Our set was a vector of numbers 1 to 3 in this case (in R a vector with a range of numbers can be made using the `:` operator in the format `start:end`). The task that we will do repetitively is `print` -- our loop body. `num` is going to store the value of the current item. Our vector or collection is the numbers 1 to 3.

The loop gets run as such:

1. `num` takes on the first value from our set (`1`)
2. the loop body runs (prints the value of `num` which is `1`)
3. there is nothing more to be done in the body so it moves onto the next item
4. `num` takes on the second value from the set (`2`)
5. the loop body runs (prints the value of `num` which is `2`)
6. there is nothing more to be done in the body so it moves to the next item
7. `num` takes on the third value from out set (`3`)
8. the loop body runs (prints the value of `num` which is `3`)
9. there is nothing more to be done in the body so it moves to the next item
10. there is not a next item so the loop exits.

This is how we could have achieved this task without a loop:

```{r}
print(1)
print(2)
print(3)
```

The duplication is apparent but not particularly laborious in this case. However, think about how this would scale. What if suddenly you needed to print the numbers 1 to 100, or 1000, or 10000? Using the copy-paste `print()` and manually filling in numbers is going to be pretty laborious and highly risky of typos. Using the `for` loop however, scales extremely easily and would be a matter of only changing what our collection of items going in was, everything else remains the same:

```{r, eval = FALSE}
for( num in 1:10000 ){
  print( num )
}
```

#### Exercise
Print out **the Column Names** of the Penguins Dataset, 1 at a time.

```{r colnames, eval=F, echo = F}
for (i in colnames(penguins)) {
  print(i)
}
```


### `for` loop with indices

One version of the `for` loop that you might encounter (especially in other languages) is a version that uses indices to determine the current item from the set. In this case rather than the loop variable using the values of the items themselves, it uses the index of the item in the collection. Traditionally the loop variable is called `i` in this situation. While you could specify the indices manually through a vector e.g. `1:5`, or `1:length(myvector)`, this can lead to some issues and the safer way is for R to generate the indices using `seq_along()` which returns a vector with all the indexes of your object.

```{r, echo = TRUE, eval = TRUE}
myNumbers <- c(11,13,15,17,19)

# show example of what seq_along() is providing
seq_along(myNumbers)

# print each number and the index used from the collection by using the index to subset
for( i in seq_along(myNumbers) ){
  print(paste("number =", myNumbers[i], "index (i) =", i))
}
```

#### Exercise
Using indices, caluclate the mean of the 2nd, 3rd and 5th Columns

```{r indicesloop, eval = F, echo = F}
# selection index
myIndex <- c(3, 4, 6)

#iterate of the index
for (i in myIndex) {
  #print(paste("Mean Column #",i,"is", mean(penguins[,i], na.rm = T)))
  print(paste("Mean", colnames(penguins)[i],"=", mean(penguins[,i], na.rm = T),2))
}
```


### Nesting of loops

It's generally recommended to avoid the nesting of loops within other loops. Let's say the outer loop has a total of `n` iterations to get through and an inner loop has `m`. Every time we add one extra iteration of the outer loop we end up adding an extra `m` iterations of the inner loop, so the total number of iterations is `n * m`. Depending on how big `m` is, this could be adding thousands or millions of extra iterations, causing your code to take longer to run. Some times however, nesting is unavoidable but it's a good idea to keep an eye out for nesting if your code is taking a while to run as this is usually the first place things can be sped up.

## Running Scripts
